
DF DF::get_data_by_idx(hmdf::Index2D<IdxT> idx) const
{
    $TPC1\left(auto df = df_.get_data_by_idx\,(idx);
    return DF(std::move(df), colmap_, colMagic_, nDtypes_);\right)
    auto s = fmt::format("invalid magic ({},{})", nDtypes_, colMagic_);
    throw std::runtime_error(s);
}

DFRView DF::get_row_view(IdxT idx) const
{
    if (idx > shape().first - 1)
    {
        auto s = fmt::format("index {} too large for DataFrame of size {}", idx, shape().first);
        throw std::out_of_range(s);
    }
    auto slice = hmdf::Index2D<IdxT>{idx,idx};
    $TPC1\left(auto view = df_.get_view_by_idx\,(slice);
    return DFRView(std::move(view), idx, this);\right)
    auto s = fmt::format("invalid magic ({},{})", nDtypes_, colMagic_);
    throw std::runtime_error(s);
}

DFR DFRView::copy() const
{
    auto idx = hmdf::Index2D<IdxT>{idx_,idx_};
    $TPC2\left(auto df = parent_->df_.get_data_by_idx\,(idx);
    return DFR(std::move(df), &(parent_->colmap_), parent_->colMagic_, parent_->nDtypes_);\right)
    auto s = fmt::format("invalid magic ({},{})", parent_->nDtypes_, parent_->colMagic_);
    throw std::runtime_error(s);
}

void DF::computeColMagic()
{
    auto dtypes = get_column_types(colmap_);
    nDtypes_ = dtypes.size();
    $COL_TP
}